//! Comprehensive benchmark comparing all FluentAi implementations

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
use fluentai_vm::{compiler::Compiler, vm::VM};

struct BenchmarkResults {
    parser_ns: f64,
    compiler_ns: f64,
    vm_ns: f64,
    jit_compile_ns: Option<f64>,
    jit_exec_ns: Option<f64>,
    total_ns: f64,
}

fn benchmark_all_implementations(c: &mut Criterion) {
    let mut group = c.benchmark_group("comprehensive_comparison");

    // Test cases with increasing complexity
    let test_cases = vec![
        ("simple_int", "42"),
        ("simple_add", "(+ 1 2)"),
        ("nested_arithmetic", "(+ (* 2 3) (- 5 1))"),
        ("complex_expression", "(+ (* 2 3) (- (+ 10 5) (* 2 4)))"),
        ("let_binding", "(let ((x 10) (y 20)) (+ x y))"),
        ("boolean_ops", "(and (> 5 3) (< 2 4))"),
    ];

    println!("\n=== FluentAi Performance Comparison ===\n");
    println!(
        "{:<20} {:>12} {:>12} {:>12} {:>14} {:>12} {:>12} {:>12}",
        "Expression",
        "Parse (ns)",
        "Compile (ns)",
        "VM (ns)",
        "JIT Compile",
        "JIT Exec",
        "Total (ns)",
        "Throughput/s"
    );
    println!("{:-<110}", "");

    let mut results = Vec::new();

    for (name, source) in &test_cases {
        let mut parse_time = 0.0;
        let mut compile_time = 0.0;
        let mut vm_time = 0.0;
        let jit_compile_time = None;
        let jit_exec_time = None;

        // Benchmark parsing
        group.bench_with_input(BenchmarkId::new("parse", name), source, |b, source| {
            b.iter(|| black_box(parse(source).unwrap()));
        });

        // Get parse timing
        let parse_result = parse(source).unwrap();
        let start = std::time::Instant::now();
        for _ in 0..10000 {
            black_box(parse(source).unwrap());
        }
        parse_time = start.elapsed().as_nanos() as f64 / 10000.0;

        // Benchmark compilation
        group.bench_with_input(
            BenchmarkId::new("compile", name),
            &parse_result,
            |b, ast| {
                b.iter(|| {
                    let compiler = Compiler::new();
                    black_box(compiler.compile(ast).unwrap())
                });
            },
        );

        // Get compile timing
        let compiler = Compiler::new();
        let start = std::time::Instant::now();
        for _ in 0..10000 {
            let compiler = Compiler::new();
            black_box(compiler.compile(&parse_result).unwrap());
        }
        compile_time = start.elapsed().as_nanos() as f64 / 10000.0;

        let bytecode = compiler.compile(&parse_result).unwrap();

        // Benchmark VM execution
        group.bench_with_input(BenchmarkId::new("vm", name), &bytecode, |b, bytecode| {
            b.iter(|| {
                let mut vm = VM::new(bytecode.clone());
                black_box(vm.run().unwrap())
            });
        });

        // Get VM timing
        let start = std::time::Instant::now();
        for _ in 0..10000 {
            let mut vm = VM::new(bytecode.clone());
            black_box(vm.run().unwrap());
        }
        vm_time = start.elapsed().as_nanos() as f64 / 10000.0;

        // JIT benchmarks (only on x86_64)
        #[cfg(target_arch = "x86_64")]
        {
            // Check if expression is JIT-compatible
            let is_jit_compatible = match *name {
                "let_binding" => false, // let not implemented in JIT
                "boolean_ops" => false, // and not implemented in JIT
                _ => true,
            };

            if is_jit_compatible {
                if let Ok(mut jit) = JitCompiler::new() {
                    // Benchmark JIT compilation
                    let start = std::time::Instant::now();
                    for _ in 0..1000 {
                        let mut jit = JitCompiler::new().unwrap();
                        black_box(jit.compile(&bytecode, 0).unwrap());
                    }
                    jit_compile_time = Some(start.elapsed().as_nanos() as f64 / 1000.0);

                    // Benchmark JIT execution
                    let func = jit.compile(&bytecode, 0).unwrap();
                    let start = std::time::Instant::now();
                    for _ in 0..10000 {
                        black_box(func());
                    }
                    jit_exec_time = Some(start.elapsed().as_nanos() as f64 / 10000.0);
                }
            }
        }

        // Calculate total and throughput
        let total_time = parse_time + compile_time + vm_time;
        let throughput = 1_000_000_000.0 / total_time;

        let jit_compile_str = jit_compile_time.map_or("N/A".to_string(), |t| format!("{:.1}", t));
        let jit_exec_str = jit_exec_time.map_or("N/A".to_string(), |t| format!("{:.1}", t));

        println!(
            "{:<20} {:>12.1} {:>12.1} {:>12.1} {:>14} {:>12} {:>12.1} {:>12.0}",
            name,
            parse_time,
            compile_time,
            vm_time,
            jit_compile_str,
            jit_exec_str,
            total_time,
            throughput
        );

        results.push(BenchmarkResults {
            parser_ns: parse_time,
            compiler_ns: compile_time,
            vm_ns: vm_time,
            jit_compile_ns: jit_compile_time,
            jit_exec_ns: jit_exec_time,
            total_ns: total_time,
        });
    }

    println!("{:-<110}", "");

    // Calculate averages
    let avg_parse = results.iter().map(|r| r.parser_ns).sum::<f64>() / results.len() as f64;
    let avg_compile = results.iter().map(|r| r.compiler_ns).sum::<f64>() / results.len() as f64;
    let avg_vm = results.iter().map(|r| r.vm_ns).sum::<f64>() / results.len() as f64;
    let avg_total = results.iter().map(|r| r.total_ns).sum::<f64>() / results.len() as f64;
    let avg_throughput = 1_000_000_000.0 / avg_total;

    // Calculate JIT averages (excluding N/A cases)
    let jit_results: Vec<_> = results
        .iter()
        .filter(|r| r.jit_compile_ns.is_some())
        .collect();
    let avg_jit_compile = if !jit_results.is_empty() {
        jit_results
            .iter()
            .map(|r| r.jit_compile_ns.unwrap())
            .sum::<f64>()
            / jit_results.len() as f64
    } else {
        0.0
    };
    let avg_jit_exec = if !jit_results.is_empty() {
        jit_results
            .iter()
            .map(|r| r.jit_exec_ns.unwrap())
            .sum::<f64>()
            / jit_results.len() as f64
    } else {
        0.0
    };

    let jit_compile_str = if !jit_results.is_empty() {
        format!("{:.1}", avg_jit_compile)
    } else {
        "N/A".to_string()
    };
    let jit_exec_str = if !jit_results.is_empty() {
        format!("{:.1}", avg_jit_exec)
    } else {
        "N/A".to_string()
    };

    println!(
        "{:<20} {:>12.1} {:>12.1} {:>12.1} {:>14} {:>12} {:>12.1} {:>12.0}",
        "AVERAGE",
        avg_parse,
        avg_compile,
        avg_vm,
        jit_compile_str,
        jit_exec_str,
        avg_total,
        avg_throughput
    );

    // Print performance summary
    println!("\n=== Performance vs Python Baseline ===\n");
    println!("Component    | Python Baseline | Rust Implementation | Speedup");
    println!("-------------|-----------------|---------------------|--------");
    println!(
        "Parser       | 19-212 µs       | {:.1}-{:.1} ns       | {:.0}x",
        results[0].parser_ns,
        results[results.len() - 1].parser_ns,
        19000.0 / avg_parse
    ); // Fix: avg_parse is already in ns, 19µs = 19000ns
    println!(
        "VM           | ~3.2 µs         | {:.1} ns             | {:.1}x",
        avg_vm,
        3200.0 / avg_vm
    ); // Fix: avg_vm is already in ns, 3.2µs = 3200ns
    if !jit_results.is_empty() {
        println!(
            "JIT Exec     | N/A             | {:.1} ns             | {:.0}x vs VM",
            avg_jit_exec,
            avg_vm / avg_jit_exec
        );
    }
    println!(
        "End-to-End   | ~22-215 µs      | {:.1}-{:.1} ns       | {:.0}x",
        results[0].total_ns,
        results[results.len() - 1].total_ns,
        22000.0 / avg_total
    ); // Fix: avg_total is already in ns, 22µs = 22000ns

    println!("\n=== Key Achievements ===");
    println!("✓ Parser: {:.0}x average speedup", 100000.0 / avg_parse); // Assuming 100µs baseline
    println!("✓ VM: {:.1}x average speedup", 3200.0 / avg_vm);
    if !jit_results.is_empty() {
        println!(
            "✓ JIT: {:.0}x speedup over VM execution",
            avg_vm / avg_jit_exec
        );
        println!("✓ JIT Compilation overhead: {:.1}ns", avg_jit_compile);
    }
    println!("✓ Overall: {:.0}x average speedup", 100000.0 / avg_total);
    println!("✓ Throughput: {:.0} operations/second", avg_throughput);

    group.finish();
}

criterion_group!(benches, benchmark_all_implementations);
criterion_main!(benches);
