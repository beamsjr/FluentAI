//! Tests for JIT closure support

use fluentai_jit::JitCompiler;
use fluentai_parser::parse_flc;
use fluentai_vm::Compiler;
use fluentai_core::value::Value;

#[test]
#[ignore = "JIT compiler requires updates to work with FLC-generated bytecode format"]
fn test_simple_function() {
    let mut jit = JitCompiler::new().unwrap();
    
    // Test a simple function definition and call
    let source = "((x) => x + 1)(5)";
    let ast = parse_flc(source).unwrap();
    let compiler = Compiler::new();
    let bytecode = compiler.compile(&ast).unwrap();

    let result = jit.compile_and_run(&bytecode).unwrap();
    // Since CALL returns dummy value 42 for now
    match result {
        Value::Integer(n) => assert_eq!(n, 42, "Expected dummy result"),
        _ => panic!("Expected integer result"),
    }
}

#[test]
#[ignore = "JIT compiler requires updates to work with FLC-generated bytecode format"]
fn test_closure_creation() {
    let mut jit = JitCompiler::new().unwrap();
    
    // Test closure that captures a variable
    let source = "let y = 10; (x) => x + y";
    let ast = parse_flc(source).unwrap();
    let compiler = Compiler::new();
    let bytecode = compiler.compile(&ast).unwrap();

    // This should create a closure
    let result = jit.compile_and_run(&bytecode).unwrap();
    match result {
        Value::Integer(_) => {
            // For now, we return a chunk_id as integer
            // In a real implementation, this would be a Function value
        }
        _ => panic!("Expected closure to be represented as integer for now"),
    }
}

#[test]
#[ignore = "JIT compiler requires updates to work with FLC-generated bytecode format"]
fn test_higher_order_function() {
    let mut jit = JitCompiler::new().unwrap();
    
    // Test function that returns a function
    let source = "private function make_adder(n) { (x) => x + n }";
    let ast = parse_flc(source).unwrap();
    let compiler = Compiler::new();
    let bytecode = compiler.compile(&ast).unwrap();

    // This defines a function
    let result = jit.compile_and_run(&bytecode).unwrap();
    // For now, just check it doesn't crash
    assert!(matches!(result, Value::Nil | Value::Integer(_)));
}